#include "SceneHierarchy.h"

#include "Core/EditorApp.h"
#include "Core/Utils/ModelLoader.h"

#include "Engine/Renderer/Primitives.h"

#include <ImGui/imgui.h>
#include <ImGui/imgui_internal.h>

namespace Editor {

	using namespace Copper;

	struct ObjectNode {

		int32_t id;
		ObjectNode* previous = nullptr;
		ObjectNode* next = nullptr;

	};

	ObjectNode* head = nullptr;

	SceneHierarchy::SceneHierarchy() : Panel("Scene Hierarchy") {

		AddObjectCreatedEventFunc(BindEventFunc(SceneHierarchy::OnObjectCreated));

	}

	void SceneHierarchy::UI() {

		scene = GetScene();
		anyNodeHovered = false;

		if (!scene) { selectedObj = Object(); }

		if (ImGui::BeginPopupContextWindow(0, 1, false)) {

			if(ImGui::MenuItem("Empty Object")) {
				
				selectedObj = scene->CreateObject("Object");
				SetChanges(true);
				
			}
			
			ImGui::Separator();

			if(ImGui::BeginMenu("3D Objects")) {

				if(ImGui::MenuItem("Plane")) {

					selectedObj = scene->CreateObject("Plane");
					MeshRenderer* renderer = selectedObj.AddComponent<MeshRenderer>();

					Mesh mesh;
					mesh.vertices = planeVertices;
					mesh.normals = planeNormals;
					mesh.colors = planeColors;
					mesh.indices = planeIndices;

					renderer->meshes.push_back(mesh);

					SetChanges(true);
					
				}
				if(ImGui::MenuItem("Cube")) {

					selectedObj = scene->CreateObject("Cube");
					MeshRenderer* renderer = selectedObj.AddComponent<MeshRenderer>();

					Mesh mesh;
					mesh.vertices = cubeVertices;
					mesh.normals  = cubeNormals;
					mesh.colors   = cubeColors;
					mesh.indices  = cubeIndices;

					renderer->meshes.push_back(mesh);

					SetChanges(true);
					
				}
				
				ImGui::EndMenu();
				
			}

			if(ImGui::MenuItem("Light")) {

				selectedObj = scene->CreateObject("Light");
				Light* l = selectedObj.AddComponent<Light>();

				SetChanges(true);
				
			}
			
			ImGui::EndPopup();
				
		}

		ObjectNode* tmp = head;
		while (tmp) {

			Object& obj = scene->GetObjectFromID(tmp->id);

			if (obj.transform->parent) { tmp = tmp->next; continue; }

			DrawObjectNode(obj);
			tmp = tmp->next;

		}

		const ImGuiPayload* payload = ImGui::GetDragDropPayload();

		if(payload && ImGui::IsWindowHovered() && ImGui::IsMouseReleased(0)) {

			if (CheckDropType("MODEL", payload->DataType)) DropModel(payload->Data);
			if (CheckDropType("OBJECT", payload->DataType)) DropObject(payload->Data);

		}

	}

	void SceneHierarchy::DrawObjectNode(Object obj) {

		std::string name = obj.tag->name;
		ImGuiTreeNodeFlags flags = ((selectedObj == obj) ? ImGuiTreeNodeFlags_Selected : 0) | ImGuiTreeNodeFlags_OpenOnArrow;

		bool opened = ImGui::TreeNodeEx((void*) (uint64_t) obj.GetID(), flags, name.c_str());

		//Magically Calculate the Rect above the Object node for rearanging the order of Objects
		//These numbers work, I know there is a better way but shush
		ImRect test;
		test.Min = ImGui::GetItemRectMin();
		test.Max = ImGui::GetItemRectMax();
		test.Min.y -= 4;
		test.Max.y -= 18;

		if (ImGui::BeginDragDropTargetCustom(test, ImGuiID(89769))) {

			if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("OBJECT")) {

				Object& objToMove = GetObjectFromID(*(int32_t*) (payload->Data));

				MoveObjectNode(obj, objToMove);

			}

			ImGui::EndDragDropTarget();

		}

		if (ImGui::BeginDragDropSource()) {

			int32_t data = obj.GetID();

			ImGui::SetDragDropPayload("OBJECT", &data, sizeof(int32_t), ImGuiCond_Once);
			ImGui::EndDragDropSource();

		}
		if (ImGui::BeginDragDropTarget()) {

			if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("OBJECT")) {

				Object& child = GetObjectFromID(*(int32_t*) (payload->Data));

				if (child.transform->parent != obj.transform && obj.transform->parent != child.transform) {

					if (child.transform->parent) {

						child.transform->parent->RemoveChild(child.transform);
						child.transform->position += child.transform->parent->GlobalPosition();

					}

					child.transform->position -= obj.transform->GlobalPosition();
					child.transform->parent = obj.transform;
					obj.transform->AddChild(child.transform);


				}

			}
			
			ImGui::EndDragDropTarget();

		}

		if (ImGui::IsItemClicked()) selectedObj = obj;
		if (!anyNodeHovered && ImGui::IsItemHovered()) anyNodeHovered = true;
		if (opened) {

			for (int i = 0; i < obj.transform->numOfChildren; i++) {
				
				DrawObjectNode(*obj.transform->GetChild(i)->object);
			
			}

			ImGui::TreePop();

		}

		if (ImGui::BeginPopupContextItem()) {

			if (ImGui::MenuItem("Delete")) {

				if (selectedObj == obj) selectedObj = Object();

				ObjectNode* tmp = head;
				while (tmp) {

					if (tmp->id == obj.GetID()) break;
					tmp = tmp->next;

				}

				tmp->previous->next = tmp->next;
				tmp->next->previous = tmp->previous;
				tmp->next = nullptr;
				tmp->previous = nullptr;

				scene->DestroyObject(obj);

			}

			ImGui::EndPopup();

		}


	}
	
	void SceneHierarchy::DropModel(void* data) {

		std::string string = (const char*) data;

		Model model;
		model.LoadMesh(string);

		selectedObj = scene->CreateObject("Model");
		MeshRenderer* renderer = selectedObj.AddComponent<MeshRenderer>();

		renderer->meshes = model.meshes;

	}
	void SceneHierarchy::DropObject(void* data) {

		if (anyNodeHovered) return;

		Object& child = GetObjectFromID(*(int32_t*) data);

		if (child.transform->parent) {

			child.transform->parent->RemoveChild(child.transform);
			child.transform->position += child.transform->parent->GlobalPosition();

		}
		child.transform->parent = nullptr;

	}

	void SceneHierarchy::MoveObjectNode(Object& obj, Object& objToMove) {

		if (obj.GetID() == objToMove.GetID()) { LogError("Can't move this Node into the same node"); return; }

		ObjectNode* objNode = nullptr;
		ObjectNode* objToMoveNode = nullptr;

		ObjectNode* tmp = head;
		while (tmp) {

			if (objNode && objToMoveNode) break;
			if (tmp->id == obj.GetID()) objNode = tmp;
			if (tmp->id == objToMove.GetID()) objToMoveNode = tmp;

			tmp = tmp->next;

		}

		if(objNode->previous == objToMoveNode) { LogError("Can't move this Node into the same node"); return; }

		if (objNode == head) {

			objToMoveNode->previous->next = objToMoveNode->next;
			if (objToMoveNode->next) objToMoveNode->next->previous = objToMoveNode->previous;

			head->previous = objToMoveNode;

			objToMoveNode->previous = nullptr;
			objToMoveNode->next = head;

			head = objToMoveNode;

		} else if (objToMoveNode == head) {

			objToMoveNode->next->previous = nullptr;
			head = objToMoveNode->next;

			objNode->previous->next = objToMoveNode;
			objToMoveNode->next = objNode;
			objToMoveNode->previous = objNode->previous;
			objNode->previous = objToMoveNode;

		} else {

			objNode->previous->next = objToMoveNode;

			objToMoveNode->previous->next = objToMoveNode->next;
			if (objToMoveNode->next) objToMoveNode->next->previous = objToMoveNode->previous;

			objToMoveNode->previous = objNode->previous;

			objToMoveNode->next = objNode;
			objNode->previous = objToMoveNode;

		}

	}

	bool SceneHierarchy::OnObjectCreated(const Event& e) {

		ObjectCreatedEvent* event = (ObjectCreatedEvent*) &e;

		//TODO: Find a way to not allocate each node on heap
		//The nodes aren't too big, but I still would like them to be on the stack
		ObjectNode* newNode = new ObjectNode();
		newNode->id = event->obj->GetID();

		//Prepare for some pointer fuckery, I don't know how and why this works, but it does
		//But we use everyones favorite thing, DoUbLe PoInTeRs YaYyYyY!!!
		ObjectNode** tmp = &head;
		while (*tmp) {

			newNode->previous = *tmp;
			tmp = &(*tmp)->next;

		}
		*tmp = newNode;

		return false;

	}

}
